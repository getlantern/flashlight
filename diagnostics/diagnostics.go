// Package diagnostics is used to generate diagnostics reports for the Flashlight application.
package diagnostics

import (
	"net"

	"github.com/jackpal/gateway"

	"github.com/getlantern/diagnostics"
	"github.com/getlantern/errors"
	"github.com/getlantern/flashlight/chained"
)

const (
	// Bump iff breaking changes are made to Report.
	reportVersion = 1

	pingCount = 5
)

// Report generated by Run.
type Report struct {
	Version int

	// Results of all tests run. The keys are the names of diagnostics tests (e.g. "ping default gateway").
	Results map[string][]diagnostics.DiagnosticResult
}

// Run the diagnostics.
func Run(proxiesMap map[string]*chained.ChainedServerInfo) Report {
	s := newSuite()
	s.initAndAdd("ping default gateway", func() (diagnostics.Diagnostic, error) {
		defaultGateway, err := gateway.DiscoverGateway()
		if err != nil {
			return nil, errors.New("failed to find default gateway: %v", err)
		}
		return &diagnostics.Ping{
			Address: defaultGateway.String(),
			Count:   pingCount,
		}, nil
	})
	proxyHosts := map[string]string{}
	for proxyName, proxyInfo := range proxiesMap {
		host, _, _ := net.SplitHostPort(proxyInfo.Addr)
		proxyHosts[proxyName] = host
	}
	s.add("ping proxies", multiPing{proxyHosts, pingCount})
	return Report{
		Version: reportVersion,
		Results: s.run(),
	}
}

type suite struct {
	d           []diagnostics.Diagnostic
	indexToName map[int]string
	initErrors  map[string][]diagnostics.DiagnosticResult
}

func newSuite() suite {
	return suite{[]diagnostics.Diagnostic{}, map[int]string{}, map[string][]diagnostics.DiagnosticResult{}}
}

// add a diagnostic to the suite. Multiple diagnostics can be registered under the same name.
func (s *suite) add(name string, d ...diagnostics.Diagnostic) {
	for _, diag := range d {
		s.indexToName[len(s.d)] = name
		s.d = append(s.d, diag)
	}
}

// initAndAdd initializes a diagnostic and adds it to the suite. If initialization fails, there will
// be an error result in the output of run.
func (s *suite) initAndAdd(name string, initFuncs ...func() (diagnostics.Diagnostic, error)) {
	for _, f := range initFuncs {
		d, err := f()
		if err != nil {
			if _, ok := s.initErrors[name]; !ok {
				s.initErrors[name] = []diagnostics.DiagnosticResult{}
			}
			s.initErrors[name] = append(s.initErrors[name], diagnostics.DiagnosticResult{
				Diagnostic: d.Type(),
				Error:      strPtr(err.Error()),
			})
		} else {
			s.add(name, d)
		}
	}
}

// run all diagnostics in the suite. Returns a map of names to results.
func (s suite) run() map[string][]diagnostics.DiagnosticResult {
	m := map[string][]diagnostics.DiagnosticResult{}
	for name, errResults := range s.initErrors {
		m[name] = errResults
	}

	results := diagnostics.Run(len(s.d), s.d...)
	for i, r := range results {
		name := s.indexToName[i]
		if _, ok := m[name]; !ok {
			m[name] = []diagnostics.DiagnosticResult{}
		}
		m[name] = append(m[name], *r)
	}
	return m
}

func strPtr(s string) *string {
	return &s
}
