// Package diagnostics is used to generate diagnostics reports for the Flashlight application.
package diagnostics

import (
	"net"

	"github.com/jackpal/gateway"

	"github.com/getlantern/diagnostics"
	"github.com/getlantern/errors"
	"github.com/getlantern/flashlight/chained"
)

const (
	// Bump iff breaking changes are made to Report.
	reportVersion = 1

	pingCount = 5
)

// Set to true to run force ping diagnostics to run on non-Windows systems. Intended for testing.
var forcePing = false

// Report generated by Run.
type Report struct {
	Version int

	PingDefaultGateway struct {
		diagnostics.PingResult `yaml:",omitempty"`
		Error                  *string `yaml:",omitempty"`
	}
	PingProxies map[string]PingResult
}

// Run the diagnostics.
func Run(proxiesMap map[string]*chained.ChainedServerInfo) Report {
	s := newSuite()
	s.initAndAdd(func() (*diagnostic, error) {
		defaultGateway, err := gateway.DiscoverGateway()
		if err != nil {
			return nil, errors.New("failed to find default gateway: %v", err)
		}
		return &diagnostic{
			&diagnostics.Ping{
				Address: defaultGateway.String(),
				Count:   pingCount,
				Force:   forcePing,
			},
			func(rep *Report, res diagnostics.DiagnosticResult) {
				if res.Error != nil {
					rep.PingDefaultGateway.Error = res.Error
				} else {
					rep.PingDefaultGateway.PingResult = *res.Result.(*diagnostics.PingResult)
				}
			},
		}, nil
	})
	proxyHosts := map[string]string{}
	for proxyName, proxyInfo := range proxiesMap {
		host, _, _ := net.SplitHostPort(proxyInfo.Addr)
		proxyHosts[proxyName] = host
	}
	s.add(diagnostic{
		multiPing{proxyHosts, pingCount},
		func(rep *Report, res diagnostics.DiagnosticResult) {
			rep.PingProxies = res.Result.(map[string]PingResult)
		},
	})
	return s.run()
}

// resultToReport adds a diagnostics.DiagnosticResult to a Report.
type resultToReport func(*Report, diagnostics.DiagnosticResult)

type diagnostic struct {
	diagnostics.Diagnostic
	addToReport resultToReport
}

type initError struct {
	result  diagnostics.DiagnosticResult
	addFunc resultToReport
}

func (ie initError) addToReport(r *Report) {
	ie.addFunc(r, ie.result)
}

type suite struct {
	d              []diagnostic
	indexToAddFunc map[int]resultToReport
	initErrors     []initError
}

func newSuite() suite {
	return suite{[]diagnostic{}, map[int]resultToReport{}, []initError{}}
}

// add a diagnostic to the suite. Multiple diagnostics can be registered under the same name.
func (s *suite) add(d ...diagnostic) {
	for _, diag := range d {
		s.indexToAddFunc[len(s.d)] = diag.addToReport
		s.d = append(s.d, diag)
	}
}

// initAndAdd initializes a diagnostic and adds it to the suite. If initialization fails, there will
// be an error result in the output of run.
func (s *suite) initAndAdd(initFuncs ...func() (*diagnostic, error)) {
	for _, f := range initFuncs {
		d, err := f()
		if err != nil {
			s.initErrors = append(s.initErrors, initError{
				result: diagnostics.DiagnosticResult{
					Diagnostic: d.Type(),
					Error:      strPtr(err.Error()),
				},
				addFunc: d.addToReport,
			})
		} else {
			s.add(*d)
		}
	}
}

func (s suite) rawDiagnostics() []diagnostics.Diagnostic {
	raw := make([]diagnostics.Diagnostic, len(s.d))
	for i, diag := range s.d {
		raw[i] = diag.Diagnostic
	}
	return raw
}

// run all diagnostics in the suite.
func (s suite) run() Report {
	r := Report{Version: reportVersion}
	for _, initErr := range s.initErrors {
		initErr.addToReport(&r)
	}
	results := diagnostics.Run(len(s.d), s.rawDiagnostics()...)
	for i, result := range results {
		s.indexToAddFunc[i](&r, *result)
	}
	return r
}

func strPtr(s string) *string {
	return &s
}
