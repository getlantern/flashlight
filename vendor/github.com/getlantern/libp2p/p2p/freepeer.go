package p2p

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	cryptoRand "crypto/rand"
	"crypto/sha1"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"math/big"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/getlantern/libp2p/common"
	"github.com/getlantern/libp2p/logger"
	"github.com/getlantern/quicproxy"
	"github.com/getlantern/upnp"
	"github.com/pkg/errors"
)

const defaultRegistrationRoutineRetryDelayIfSuccessful = time.Minute * 15
const defaultRegistrationRoutineRetryDelayIfFailed = time.Second * 15

type FreePeerCtxInput struct {
	Port                     int
	GetIpv4Addr, GetIpv6Addr func() (net.IP, error)
	// Leave this empty to not communicate with the Registrar at all. This is
	// exclusively useful for testing
	RegistrarEndpoint     string
	Verbose               bool
	DoPortforwardWithUpnp bool
	AppConfigPath         string
	// The interval at which to retry hitting p2pregistrar's "/register"
	// endpoint to register this FreePeer's proxy info in the p2pregistrar.
	// Leave as 0 to use the defaults
	RetryRegistrationDelayIfSuccessful time.Duration
	RetryRegistrationDelayIfFailed     time.Duration
	// List of allowed domains that this FreePeer's proxy can proxy to.
	// Any request coming to this FreePeer's proxy that is not allowed will
	// be rejected (with a 403 StatusForbidden).
	//
	// If this is nil, it will default to "geo.getiantem.org" (i.e., Lantern's
	// default geolookup domain).
	//
	// Finally, the string comparisons are done case-insensitive and with
	// substrings, meaning that if you just put "google" here, it'll accept
	// "maps.google.com", "photos.GOOGLE.com", etc.
	//
	// **IMPORTANT** This is really a hyperparameter.
	AllowedDomainsToProxyTo []string
	// If this is supplied, this will be used in lieu of a newly-generated
	// MetricsToken (see description in FreePeerCtx). This is really exclusive
	// to tests
	InjectedMetricsToken string
}

func (i *FreePeerCtxInput) parseAndSetDefaults() error {
	if i.Port < 0 || i.Port > 65535 {
		return errors.New("port is not set")
	}
	if i.RegistrarEndpoint != "" {
		i.RegistrarEndpoint = strings.TrimSuffix(i.RegistrarEndpoint, "/")
	}

	if i.AppConfigPath == "" {
		return errors.New("app config path is not set")
	}

	if i.GetIpv4Addr == nil {
		i.GetIpv4Addr = func() (net.IP, error) { return nil, nil }
	}
	if i.GetIpv6Addr == nil {
		i.GetIpv6Addr = func() (net.IP, error) { return nil, nil }
	}
	if i.RetryRegistrationDelayIfFailed == 0 {
		i.RetryRegistrationDelayIfFailed = defaultRegistrationRoutineRetryDelayIfFailed
	}
	if i.RetryRegistrationDelayIfSuccessful == 0 {
		i.RetryRegistrationDelayIfSuccessful = defaultRegistrationRoutineRetryDelayIfSuccessful
	}
	if i.AllowedDomainsToProxyTo == nil {
		// At least allow geolookups
		i.AllowedDomainsToProxyTo = []string{"geo.getiantem.org"}
	}
	return nil
}

type FreePeerCtx struct {
	ReverseProxyServer *quicproxy.QuicReverseProxy
	// Generated by the FreePeerCtx and sent to the p2pregistrar during a
	// registration. This is used by the p2pregistrar to fetch usage metrics
	// from this peer
	MetricsToken string
	// Usage metrics by this peer's reverse proxy
	TotalBytesRead    int64
	TotalBytesWritten int64

	input      *FreePeerCtxInput
	upnpClient *upnp.Client
	// doneChan is only used for its closed state and it's closed when this
	// peer is closed and no other work from this struct should continue
	doneChan   chan struct{}
	doneOnce   sync.Once
	registerMu sync.Mutex

	pubKey, privKey, cert []byte
}

// Converts this FreePeer context to a GenericFreePeer struct
func (fpc *FreePeerCtx) ToGenericFreePeer() (*common.GenericFreePeer, error) {
	ip, err := fpc.input.GetIpv4Addr()
	if err != nil {
		return nil, err
	}
	return &common.GenericFreePeer{
		IP:                 ip,
		Port:               fpc.ReverseProxyServer.Port,
		PubCertFingerprint: fpc.cert,
		// XXX <15-06-2022, soltzen> CountryCode is really only relevant for
		// metrics and can be ignored here
	}, nil
}

// RunFreePeer creates a new FreePeerCtx struct and runs it
// A few characteristics of this FreePeer:
// - Has a ReverseProxy that accepts traffic from a CensoredPeer's ForwardProxy
// - Runs a registration routine that periodically hits p2pregistrar's
//   "/register" endpoint to register this FreePeer's proxy info.
// - Has a UPNP portforwarder that forwards this FreePeer's port to the
//   Internet.
// - Has a metrics token that is used by p2pregistrar to fetch usage metrics
//   from this peer.
func RunFreePeer(
	input *FreePeerCtxInput,
) (*FreePeerCtx, error) {
	logger.Log.Infof("Running a new FreePeerCtx")
	if err := input.parseAndSetDefaults(); err != nil {
		return nil, err
	}

	fpc := &FreePeerCtx{
		input:      input,
		doneChan:   make(chan struct{}),
		upnpClient: upnp.New(),
	}

	// Generate keypair and cert and save it somewhere
	pemEncodedPrivKey, pemEncodedPubKey,
		pemEncodedCert, err := generateSelfSignedX509Cert()
	if err != nil {
		return nil, errors.Wrapf(err, "while generating self-signed cert")
	}
	err = saveCertsAndKeysLocally(
		pemEncodedPrivKey, pemEncodedPubKey,
		pemEncodedCert,
		getFreePeerCertsPath(input.AppConfigPath))
	if err != nil {
		return nil, errors.Wrapf(err, "while saving keys")
	}
	fpc.privKey = pemEncodedPrivKey
	fpc.pubKey = pemEncodedPubKey
	fpc.cert = pemEncodedCert

	// Make metrics token
	b := make([]byte, 20)
	_, err = cryptoRand.Read(b)
	if err != nil {
		return nil, errors.Wrapf(err, "while generating metrics token")
	}
	if input.InjectedMetricsToken != "" {
		fpc.MetricsToken = input.InjectedMetricsToken
	} else {
		fpc.MetricsToken = hex.EncodeToString(b)
	}

	// Run the reverse proxy
	errChan := make(chan error)
	fpc.ReverseProxyServer, err = quicproxy.NewReverseProxy(
		":"+strconv.Itoa(input.Port), // addr
		pemEncodedCert,
		pemEncodedPrivKey,
		input.Verbose,
		errChan,
		// trackReadBytes func
		func(host string, n int64) {
			logger.Log.Infof("$$$ %s: %d bytes read\n", host, n)
			fpc.TotalBytesRead += n
		},
		// trackWritteBytes func
		func(host string, n int64) {
			logger.Log.Infof("$$$ %s: %d bytes written\n", host, n)
			fpc.TotalBytesWritten += n
		},
		// MetricsHandler: we use this to serve usage metrics for
		// this FreePeer if and only if the URL path matches
		// "/metrics".
		// Else, try to proxy this request.
		func(w http.ResponseWriter, req *http.Request) int64 {
			handleMetricsRoute(
				w,
				req,
				fpc.TotalBytesRead,
				fpc.TotalBytesWritten,
				fpc.MetricsToken,
			)
			return 0
		},
		// AllowedDomainHandler: we use this to only proxy requests from
		// whitelisted domains. Returns true if the domain is whitelisted and
		// false otherwise.
		func(domain string) bool {
			for _, allowedDomain := range input.AllowedDomainsToProxyTo {
				if strings.Contains(
					strings.ToLower(domain),
					strings.ToLower(allowedDomain),
				) {
					return true
				}
			}
			return false
		},
	)
	if err != nil {
		return nil, errors.Wrapf(err, "while NewReverseProxy")
	}
	logger.Log.Infof(
		"Successfully created a reverse proxy for free p2p peer on 0.0.0.0:%v",
		fpc.ReverseProxyServer.Port)

	// See if we need to port forward with UPNP
	if input.DoPortforwardWithUpnp {
		err := fpc.upnpClient.ForwardPortWithUpnp(
			uint16(fpc.ReverseProxyServer.Port),
			"udp",
		)
		if err != nil {
			// Don't die: we might still continue without UPNP
			// TODO <11-07-2022, soltzen> This is prime use case for
			// https://github.com/getlantern/portchecker
			logger.Log.Errorf("Failed to portforward udp:%d with upnp")
		} else {
			logger.Log.Infof(
				"Successfully portforwarded udp:%d with upnp",
				fpc.ReverseProxyServer.Port,
			)
		}
	}

	// Listen for errors and quit if any occurs
	go func() {
		for err := range errChan {
			logger.Log.Errorf("while running FreePeer: %v", err)
			ctx, cancel := context.WithTimeout(context.Background(),
				10*time.Second)
			fpc.Close(ctx)
			cancel()
		}
	}()

	// Start registration routine
	if input.RegistrarEndpoint != "" {
		go fpc.StartProxyRegistrationRoutine(
			fpc.input.RetryRegistrationDelayIfSuccessful,
			fpc.input.RetryRegistrationDelayIfFailed,
		)
	}

	return fpc, nil
}

// Close shutsdown this peer's resources.
func (fpc *FreePeerCtx) Close(ctx context.Context) {
	fpc.doneOnce.Do(func() {
		logger.Log.Infof("Free peer: Closing...")
		if fpc.ReverseProxyServer != nil {
			err := fpc.ReverseProxyServer.Shutdown(ctx)
			if err != nil {
				logger.Log.Infof(
					"Error while closing reverse proxy server: %v",
					err,
				)
			}
		}
		close(fpc.doneChan)
	})
}

func getFreePeerCertsPath(appConfigPath string) string {
	return filepath.Join(appConfigPath, "p2p-certs")
}

// StartProxyRegistrationRoutine runs "registerProxy()" to register FreePeerCtx
// to the p2pregistrar every "retryDelayWhenSuccessful" seconds to the
// registrar, or every "retryDelayWhenFailed" seconds if the registration
// failed.
func (fpc *FreePeerCtx) StartProxyRegistrationRoutine(
	retryDelayWhenSuccessful, retryDelayWhenFailed time.Duration) {
	// Make a cancellable context that dies if the close channel is closed
	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		<-fpc.doneChan
		cancel()
	}()

	for {
		err := registerProxy(
			ctx,
			&fpc.registerMu,
			fpc.input.RegistrarEndpoint,
			fpc.input.GetIpv4Addr,
			fpc.ReverseProxyServer.Port,
			fpc.pubKey, fpc.cert,
			fpc.MetricsToken,
		)
		var retryDuration time.Duration
		if err != nil {
			retryDuration = retryDelayWhenFailed
			logger.Log.Errorf(
				"while registering to registrar [%v]. Rerunning registration in %v",
				err,
				retryDuration,
			)
		} else {
			retryDuration = retryDelayWhenSuccessful
			logger.Log.Infof("Successfully registered to registrar. Rerunning the registration in %v", retryDuration)
		}

		// Check if we're closed (either the entire peer is closed or we don't
		// need to register anymore)
		select {
		case <-ctx.Done():
			return
		case <-time.After(retryDuration):
		}
	}
}

type RegisterRouteRequest struct {
	IP                 string `json:"ip"`
	Port               int    `json:"port"`
	PubCertFingerprint string `json:"pub-cert-fingerprint"`
	MetricsToken       string `json:"metrics-token"`
}

// registerProxy registers the given IP, port, pubKey and pubCert params to the
// p2pregistrar instance living in "registrarEndpoint"
func registerProxy(
	ctx context.Context,
	mu *sync.Mutex,
	registrarEndpoint string,
	getIpv4Addr func() (net.IP, error),
	port int,
	pubKey, pubCert []byte,
	metricsToken string,
) error {
	mu.Lock()
	defer mu.Unlock()

	logger.Log.Infof("Registering to registrar...")

	ipv4Addr, err := getIpv4Addr()
	if err != nil {
		return errors.Wrapf(err, "while getting ipv4 address")
	}
	pubCertFingerprint := sha1.Sum(pubCert)
	typedReq := RegisterRouteRequest{
		IP:   ipv4Addr.String(),
		Port: port,
		// PubKey:             hex.EncodeToString(pubKey),
		PubCertFingerprint: hex.EncodeToString(pubCertFingerprint[:]),
		MetricsToken:       metricsToken,
	}
	b, err := json.Marshal(typedReq)
	if err != nil {
		return errors.Wrapf(err, "while marshalling request")
	}

	req, err := http.NewRequestWithContext(
		ctx,
		"POST",
		registrarEndpoint+"/register",
		bytes.NewBuffer(b),
	)
	if err != nil {
		return errors.Wrapf(err, "while creating request")
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return errors.Wrapf(err, "while sending request")
	}
	if resp.StatusCode != http.StatusOK {
		return errors.Errorf("unexpected status code: %v", resp.StatusCode)
	}
	defer resp.Body.Close()
	logger.Log.Infof("Registered with registrar successfully")
	return nil
}

// Uses NIST P-256 curve
func generateSelfSignedX509Cert() ([]byte, []byte, []byte, error) {
	privKey, err := ecdsa.GenerateKey(elliptic.P256(), cryptoRand.Reader)
	if err != nil {
		return nil, nil, nil, errors.Wrapf(err, "while generating keypair")
	}
	template := x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			Organization: []string{"Free Peer"},
		},
		NotBefore: time.Now(),
		// TODO <11-02-22, soltzen> Make this variable? Do we need to worry when this expires?
		NotAfter:              time.Now().Add(time.Hour * 24 * 360),
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IsCA:                  false,
	}

	derEncodedCert, err := x509.CreateCertificate(
		cryptoRand.Reader, &template, &template, &privKey.PublicKey, privKey)
	if err != nil {
		return nil, nil, nil, errors.Wrapf(err, "while creating certificate")
	}
	pemEncodedCert := pem.EncodeToMemory(
		&pem.Block{Type: "CERTIFICATE", Bytes: derEncodedCert},
	)

	derEncodedPrivKey, err := x509.MarshalECPrivateKey(privKey)
	if err != nil {
		return nil, nil, nil, errors.Wrapf(
			err,
			"while DER-encoding private key",
		)
	}
	pemEncodedPrivKey := pem.EncodeToMemory(
		&pem.Block{Type: "EC PRIVATE KEY", Bytes: derEncodedPrivKey},
	)

	derEncodedPubKey, err := x509.MarshalPKIXPublicKey(&privKey.PublicKey)
	if err != nil {
		return nil, nil, nil, errors.Wrapf(err, "while DER-encoding public key")
	}
	pemEncodedPubKey := pem.EncodeToMemory(
		&pem.Block{Type: "EC PUBLIC KEY", Bytes: derEncodedPubKey},
	)

	return pemEncodedPrivKey, pemEncodedPubKey, pemEncodedCert, nil
}

func saveCertsAndKeysLocally(
	pemEncodedPrivKey, pemEncodedPubKey,
	pemEncodedCert []byte,
	targetDir string) error {
	err := os.MkdirAll(targetDir, os.ModePerm)
	if err != nil {
		return errors.Wrapf(
			err,
			"while creating targetDir [%s] cert",
			targetDir,
		)
	}
	err = os.WriteFile(
		filepath.Join(targetDir, "freepeer-cert.pem"),
		pemEncodedCert, 0o600)
	if err != nil {
		return errors.Wrapf(err, "while saving free peer cert")
	}
	err = os.WriteFile(
		filepath.Join(targetDir, "freepeer-priv-key.pem"),
		pemEncodedPrivKey, 0o600)
	if err != nil {
		return errors.Wrapf(err, "while saving free peer privkey")
	}
	err = os.WriteFile(
		filepath.Join(targetDir, "freepeer-pub-key.pem"),
		pemEncodedPubKey, 0o666)
	if err != nil {
		return errors.Wrapf(err, "while saving free peer pubKey")
	}
	return nil
}

func handleMetricsRoute(
	w http.ResponseWriter,
	r *http.Request,
	totalBytesRead, totalBytesWritten int64,
	metricsToken string,
) {
	if metricsToken == "" {
		logger.Log.Errorf("Metrics route called without token")
		w.WriteHeader(http.StatusNotFound)
		return
	}

	// Check authentication
	if r.URL.Query().Get("token") != metricsToken {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	// Return metrics response
	typedResp := common.MetricsRouteResponse{
		TotalBytesRead:    totalBytesRead,
		TotalBytesWritten: totalBytesWritten,
	}
	resp, err := json.Marshal(typedResp)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Write the response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_, err = w.Write(resp)
	if err != nil {
		logger.Log.Errorf("Error while writing metrics response: %v", err)
	}
}
