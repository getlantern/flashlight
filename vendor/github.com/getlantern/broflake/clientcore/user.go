// user.go provides a facility for proxying user-generated bytestreams - ie, streams which
// originate from a process running on the user's computer (like a web browser) or streams which
// are generated as part of the user's Lantern control plane activity. We can operationalize a
// user stream in a WorkerFSM just like we do an RTCPeerConnection or a websocket.Conn, such that
// bytestreams from the user can be neatly managed alongside bytestreams from remote peers in
// their consumer table. In other words: we treat the user's web browser just like any connected consumer.
package clientcore

import (
	"context"
	"log"
	"net"
	"sync"

	"github.com/getlantern/broflake/common"
)

type BroflakeConn struct {
	net.PacketConn
	writeChan chan IPCMsg
	readChan  chan IPCMsg
}

func (c BroflakeConn) LocalAddr() net.Addr {
	return common.DebugAddr("DEBUG NELSON WUZ HERE")
}

func (c BroflakeConn) ReadFrom(p []byte) (n int, addr net.Addr, err error) {
	msg := <-c.readChan
	payload := msg.Data.([]byte)
	copy(p, payload)
	return len(payload), common.DebugAddr("DEBUG NELSON WUZ HERE"), nil
}

func (c BroflakeConn) WriteTo(p []byte, addr net.Addr) (n int, err error) {
	// TODO: This copy seems necessary to avoid a data race
	b := make([]byte, len(p))
	copy(b, p)

	select {
	case c.writeChan <- IPCMsg{IpcType: ChunkIPC, Data: b}:
		// Do nothing, message sent
	default:
		// Drop the chunk if we can't keep up with the data rate
	}

	return len(b), nil
}

func NewProducerUserStream(wg *sync.WaitGroup) (*BroflakeConn, *WorkerFSM) {
	worker := NewWorkerFSM(wg, []FSMstate{
		FSMstate(func(ctx context.Context, com *ipcChan, input []interface{}) (int, []interface{}) {
			// State 0
			// (no input data)
			log.Printf("User stream producer state 0...\n")
			// TODO: check for a non-nil path assertion to alert the UI that we're ready to proxy?
			select {}
		}),
	})

	bfconn := BroflakeConn{PacketConn: &net.UDPConn{}, writeChan: worker.com.tx, readChan: worker.com.rx}
	return &bfconn, worker
}
